<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>QuanergyClient: quanergy::calibration::EncoderAngleCalibration Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">QuanergyClient
   &#160;<span id="projectnumber">3.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacequanergy.html">quanergy</a></li><li class="navelem"><b>calibration</b></li><li class="navelem"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html">EncoderAngleCalibration</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="structquanergy_1_1calibration_1_1EncoderAngleCalibration-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">quanergy::calibration::EncoderAngleCalibration Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class calculates the error in the encoder angles and returns the amplitude and phase shift of the sine function modeling the error in the encoder angles for the M8 Sensor. This class can also be provided with the sine error parameters and apply the calibration to incoming points.  
 <a href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="encoder__angle__calibration_8h_source.html">encoder_angle_calibration.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad2e08ae4ae94662029c907d43c5f879c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#ad2e08ae4ae94662029c907d43c5f879c">AngleContainer</a> = std::vector&lt; double &gt;</td></tr>
<tr class="separator:ad2e08ae4ae94662029c907d43c5f879c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989e77cbef9730169908a437323a96c2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#a989e77cbef9730169908a437323a96c2">SineParameters</a> = std::pair&lt; double, double &gt;</td></tr>
<tr class="separator:a989e77cbef9730169908a437323a96c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41576cd5cbf0b1d917a9a781be9e308"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#aa41576cd5cbf0b1d917a9a781be9e308">LineParameters</a> = std::pair&lt; double, double &gt;</td></tr>
<tr class="separator:aa41576cd5cbf0b1d917a9a781be9e308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50457c8a6ce95e6c44c3aa32659ee40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae50457c8a6ce95e6c44c3aa32659ee40"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#ae50457c8a6ce95e6c44c3aa32659ee40">Ptr</a> = std::shared_ptr&lt; <a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html">EncoderAngleCalibration</a> &gt;</td></tr>
<tr class="memdesc:ae50457c8a6ce95e6c44c3aa32659ee40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short-hand for point types. <br/></td></tr>
<tr class="separator:ae50457c8a6ce95e6c44c3aa32659ee40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f20fa67f6d6bff7b21b76f695489f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32f20fa67f6d6bff7b21b76f695489f7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#a32f20fa67f6d6bff7b21b76f695489f7">ResultType</a> = PointCloudHVDIRPtr</td></tr>
<tr class="memdesc:a32f20fa67f6d6bff7b21b76f695489f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result type for class. <br/></td></tr>
<tr class="separator:a32f20fa67f6d6bff7b21b76f695489f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5bc875838932085c43143e44a2942a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb5bc875838932085c43143e44a2942a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#aeb5bc875838932085c43143e44a2942a">Signal</a> = boost::signals2::signal&lt; void(const <a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#a32f20fa67f6d6bff7b21b76f695489f7">ResultType</a> &amp;)&gt;</td></tr>
<tr class="memdesc:aeb5bc875838932085c43143e44a2942a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal type. <br/></td></tr>
<tr class="separator:aeb5bc875838932085c43143e44a2942a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4c86719a8e5a36a1b14dba38e5bd4901"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c86719a8e5a36a1b14dba38e5bd4901"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#a4c86719a8e5a36a1b14dba38e5bd4901">EncoderAngleCalibration</a> ()</td></tr>
<tr class="memdesc:a4c86719a8e5a36a1b14dba38e5bd4901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="separator:a4c86719a8e5a36a1b14dba38e5bd4901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa758e2353874d4d8a2d49c28fce4ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0fa758e2353874d4d8a2d49c28fce4ba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#a0fa758e2353874d4d8a2d49c28fce4ba">~EncoderAngleCalibration</a> ()</td></tr>
<tr class="memdesc:a0fa758e2353874d4d8a2d49c28fce4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty destructor. <br/></td></tr>
<tr class="separator:a0fa758e2353874d4d8a2d49c28fce4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1d924f8633dcb48898c32d7fabf651"><td class="memItemLeft" align="right" valign="top">boost::signals2::connection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#a1b1d924f8633dcb48898c32d7fabf651">connect</a> (const TYPENAME Signal::slot_type &amp;subscriber)</td></tr>
<tr class="memdesc:a1b1d924f8633dcb48898c32d7fabf651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds subscriber to be called after this classes functionality is done.  <a href="#a1b1d924f8633dcb48898c32d7fabf651">More...</a><br/></td></tr>
<tr class="separator:a1b1d924f8633dcb48898c32d7fabf651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73746735a610fe7f4b9a261f5eabf9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#ac73746735a610fe7f4b9a261f5eabf9f">slot</a> (PointCloudHVDIRPtr const &amp;pc)</td></tr>
<tr class="memdesc:ac73746735a610fe7f4b9a261f5eabf9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slot to be connected as a subscriber to another process. If calibration is not complete, this function will add the point cloud argument to the cloud to be used for calibration. If calibration is complete, this function will apply the calibration and call the next subscriber.  <a href="#ac73746735a610fe7f4b9a261f5eabf9f">More...</a><br/></td></tr>
<tr class="separator:ac73746735a610fe7f4b9a261f5eabf9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0f552b95aa74d0738d7c5d7e89d1fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd0f552b95aa74d0738d7c5d7e89d1fa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#acd0f552b95aa74d0738d7c5d7e89d1fa">calibrateOnly</a> ()</td></tr>
<tr class="memdesc:acd0f552b95aa74d0738d7c5d7e89d1fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this class to only calculate the error parameters and not apply the calibration. This mode is for when the caller wants to look at multiple calculations for the amplitude and phase. <br/></td></tr>
<tr class="separator:acd0f552b95aa74d0738d7c5d7e89d1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86be4f4d781cad40afab05f40ad78d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#aa86be4f4d781cad40afab05f40ad78d6">setRequiredNumSamples</a> (double num_cals)</td></tr>
<tr class="memdesc:aa86be4f4d781cad40afab05f40ad78d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets number of valid calibrations to be collected before averaging. Validity is determined by change in phase between current sample and previous sample.  <a href="#aa86be4f4d781cad40afab05f40ad78d6">More...</a><br/></td></tr>
<tr class="separator:aa86be4f4d781cad40afab05f40ad78d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9d48e2c8ccaf03647dde2666985819"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#a0f9d48e2c8ccaf03647dde2666985819">setParams</a> (double amplitude, double phase)</td></tr>
<tr class="memdesc:a0f9d48e2c8ccaf03647dde2666985819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to manually set calibration parameters. Calling this function will disable the automatic calibration and subsequent calls to slot will apply the calibration and call the subscriber.  <a href="#a0f9d48e2c8ccaf03647dde2666985819">More...</a><br/></td></tr>
<tr class="separator:a0f9d48e2c8ccaf03647dde2666985819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe3b279f9dbed5e17e91bbe4271943d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#a8fe3b279f9dbed5e17e91bbe4271943d">setFrameRate</a> (double frame_rate)</td></tr>
<tr class="memdesc:a8fe3b279f9dbed5e17e91bbe4271943d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set frame rate. Value is in frames per second. If not set, the default is 10.  <a href="#a8fe3b279f9dbed5e17e91bbe4271943d">More...</a><br/></td></tr>
<tr class="separator:a8fe3b279f9dbed5e17e91bbe4271943d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478a432ee011bab690954869f8638ce1"><td class="memTemplParams" colspan="2">template&lt;typename Rep , typename Period &gt; </td></tr>
<tr class="memitem:a478a432ee011bab690954869f8638ce1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#a478a432ee011bab690954869f8638ce1">setTimeout</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;timeout)</td></tr>
<tr class="memdesc:a478a432ee011bab690954869f8638ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets timeout for calculating the calibration. If the timeout expires this class will throw an exception.  <a href="#a478a432ee011bab690954869f8638ce1">More...</a><br/></td></tr>
<tr class="separator:a478a432ee011bab690954869f8638ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4dc14bab7cad0d55e9466e044424a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#a989e77cbef9730169908a437323a96c2">SineParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#a2c4dc14bab7cad0d55e9466e044424a2">calculate</a> (const std::vector&lt; double &gt; &amp;encoder_angles)</td></tr>
<tr class="memdesc:a2c4dc14bab7cad0d55e9466e044424a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate the sinusoidal error of the horizontal encoder values. This function is called once a full revolution of the encoder is captured.  <a href="#a2c4dc14bab7cad0d55e9466e044424a2">More...</a><br/></td></tr>
<tr class="separator:a2c4dc14bab7cad0d55e9466e044424a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a76aedeeacc4ac54b5fa1324a144abaf6"><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#a76aedeeacc4ac54b5fa1324a144abaf6">FIRING_RATE</a></td></tr>
<tr class="separator:a76aedeeacc4ac54b5fa1324a144abaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78466d125a2b3c71199e06bb8f433738"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#a78466d125a2b3c71199e06bb8f433738">ENCODER_COUNT_TOLERANCE</a></td></tr>
<tr class="separator:a78466d125a2b3c71199e06bb8f433738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe79c88a1e3a3e42796a225e34c1d67f"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#abe79c88a1e3a3e42796a225e34c1d67f">MIN_ENCODER_ANGLES_PER_REV</a></td></tr>
<tr class="separator:abe79c88a1e3a3e42796a225e34c1d67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42e578d8a1c168e7d75506faad03dc2"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#ab42e578d8a1c168e7d75506faad03dc2">MAX_ENCODER_ANGLES_PER_REV</a></td></tr>
<tr class="separator:ab42e578d8a1c168e7d75506faad03dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934b8f1f5c14ed61c7ba6bc5e01ddd5b"><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#a934b8f1f5c14ed61c7ba6bc5e01ddd5b">PI_TOLERANCE</a></td></tr>
<tr class="separator:a934b8f1f5c14ed61c7ba6bc5e01ddd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d42f1ff560d67d491511970960f0cfa"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#a0d42f1ff560d67d491511970960f0cfa">MOV_AVG_PERIOD</a></td></tr>
<tr class="separator:a0d42f1ff560d67d491511970960f0cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12436409c1f1f10f4c005e45fcfbfbf2"><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#a12436409c1f1f10f4c005e45fcfbfbf2">PHASE_CONVERGENCE_THRESHOLD</a></td></tr>
<tr class="separator:a12436409c1f1f10f4c005e45fcfbfbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9a418e7547fb16216a839a0f605b47"><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#a1b9a418e7547fb16216a839a0f605b47">AMPLITUDE_THRESHOLD</a></td></tr>
<tr class="separator:a1b9a418e7547fb16216a839a0f605b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class calculates the error in the encoder angles and returns the amplitude and phase shift of the sine function modeling the error in the encoder angles for the M8 Sensor. This class can also be provided with the sine error parameters and apply the calibration to incoming points. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ad2e08ae4ae94662029c907d43c5f879c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#ad2e08ae4ae94662029c907d43c5f879c">quanergy::calibration::EncoderAngleCalibration::AngleContainer</a> =  std::vector&lt;double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of the container that contains the encoder angles </p>

</div>
</div>
<a class="anchor" id="aa41576cd5cbf0b1d917a9a781be9e308"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#aa41576cd5cbf0b1d917a9a781be9e308">quanergy::calibration::EncoderAngleCalibration::LineParameters</a> =  std::pair&lt;double, double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type holds the parameters of a 2d line </p>

</div>
</div>
<a class="anchor" id="a989e77cbef9730169908a437323a96c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#a989e77cbef9730169908a437323a96c2">quanergy::calibration::EncoderAngleCalibration::SineParameters</a> =  std::pair&lt;double, double&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type holds the parameters of the sine wave. The amplitude is the first element of the pair, the phase is the second element. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2c4dc14bab7cad0d55e9466e044424a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structquanergy_1_1calibration_1_1EncoderAngleCalibration.html#a989e77cbef9730169908a437323a96c2">SineParameters</a> quanergy::calibration::EncoderAngleCalibration::calculate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>encoder_angles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to calculate the sinusoidal error of the horizontal encoder values. This function is called once a full revolution of the encoder is captured. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">encoder_angles</td><td>Encoder angles</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tuple with first element as the amplitude of the sinusoid and second element as the phase offset of the sinusoid. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b1d924f8633dcb48898c32d7fabf651"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::connection quanergy::calibration::EncoderAngleCalibration::connect </td>
          <td>(</td>
          <td class="paramtype">const TYPENAME Signal::slot_type &amp;&#160;</td>
          <td class="paramname"><em>subscriber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds subscriber to be called after this classes functionality is done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subscriber</td><td>Subscriber to be called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>connection between this class and subscriber </dd></dl>

</div>
</div>
<a class="anchor" id="a8fe3b279f9dbed5e17e91bbe4271943d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void quanergy::calibration::EncoderAngleCalibration::setFrameRate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>frame_rate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to set frame rate. Value is in frames per second. If not set, the default is 10. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frame_rate</td><td>frame rate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0f9d48e2c8ccaf03647dde2666985819"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void quanergy::calibration::EncoderAngleCalibration::setParams </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>amplitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>phase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to manually set calibration parameters. Calling this function will disable the automatic calibration and subsequent calls to slot will apply the calibration and call the subscriber. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">amplitude</td><td>Amplitude of sinusoid error </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phase</td><td>Phase of sinusoidal error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa86be4f4d781cad40afab05f40ad78d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void quanergy::calibration::EncoderAngleCalibration::setRequiredNumSamples </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>num_cals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets number of valid calibrations to be collected before averaging. Validity is determined by change in phase between current sample and previous sample. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_cals</td><td>Number of calibrations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a478a432ee011bab690954869f8638ce1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , typename Period &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void quanergy::calibration::EncoderAngleCalibration::setTimeout </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets timeout for calculating the calibration. If the timeout expires this class will throw an exception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Timeout. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac73746735a610fe7f4b9a261f5eabf9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void quanergy::calibration::EncoderAngleCalibration::slot </td>
          <td>(</td>
          <td class="paramtype">PointCloudHVDIRPtr const &amp;&#160;</td>
          <td class="paramname"><em>pc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slot to be connected as a subscriber to another process. If calibration is not complete, this function will add the point cloud argument to the cloud to be used for calibration. If calibration is complete, this function will apply the calibration and call the next subscriber. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pc</td><td>Point cloud to be processed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a1b9a418e7547fb16216a839a0f605b47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double quanergy::calibration::EncoderAngleCalibration::AMPLITUDE_THRESHOLD</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Amplitude threshold dictating if calculating the encoder offset is appropriate. If an encoder calibration returns an amplitude below this value, this class indicates that calibration is complete and applies no calibration to outgoing points. </p>

</div>
</div>
<a class="anchor" id="a78466d125a2b3c71199e06bb8f433738"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int quanergy::calibration::EncoderAngleCalibration::ENCODER_COUNT_TOLERANCE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Once the motor has reached stead-state, the number of encoder counts per revolution should be roughly the firing rate divided by the frame rate. This number is how many counts the current revolution can be within the theoretical steady-state number of encoder counts. </p>

</div>
</div>
<a class="anchor" id="a76aedeeacc4ac54b5fa1324a144abaf6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double quanergy::calibration::EncoderAngleCalibration::FIRING_RATE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The firing rate of the LiDAR, in Hz </p>

</div>
</div>
<a class="anchor" id="ab42e578d8a1c168e7d75506faad03dc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int quanergy::calibration::EncoderAngleCalibration::MAX_ENCODER_ANGLES_PER_REV</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maximum number of encoder angles to qualify full revolution at steady-state motor speed </p>

</div>
</div>
<a class="anchor" id="abe79c88a1e3a3e42796a225e34c1d67f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int quanergy::calibration::EncoderAngleCalibration::MIN_ENCODER_ANGLES_PER_REV</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Minimum number of encoder angles to qualify full revolution at steady-state motor speed </p>

</div>
</div>
<a class="anchor" id="a0d42f1ff560d67d491511970960f0cfa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int quanergy::calibration::EncoderAngleCalibration::MOV_AVG_PERIOD</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Moving average period to use when smoothing error signal, in encoder counts </p>

</div>
</div>
<a class="anchor" id="a12436409c1f1f10f4c005e45fcfbfbf2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double quanergy::calibration::EncoderAngleCalibration::PHASE_CONVERGENCE_THRESHOLD</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tolerance for identifying when phase values have converged without outliers </p>

</div>
</div>
<a class="anchor" id="a934b8f1f5c14ed61c7ba6bc5e01ddd5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double quanergy::calibration::EncoderAngleCalibration::PI_TOLERANCE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allowable tolerance within pi for an endpoint-angle in a revolution to be considered near pi </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="encoder__angle__calibration_8h_source.html">encoder_angle_calibration.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 15 2018 15:35:53 for QuanergyClient by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
